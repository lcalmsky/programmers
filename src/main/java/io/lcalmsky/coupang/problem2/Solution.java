package io.lcalmsky.coupang.problem2;

import java.util.HashMap;
import java.util.Map;

/**
 * <pre>
 * 문제 설명
 * 윤주는 취미 삼아 탁구장에 다니면서 탁구를 즐기고 있는데, 다음 달부터 매달 윤주네 탁구장에서 토너먼트 경기가 있을 예정입니다. 윤주도 다음 달 대회에 참가 신청을 하였고, 대진표를 받아보았습니다. 그런데 윤주가 받은 대진표에는 무작위로 부전승이 끼어 있었습니다. 아래는 윤주가 받은 대진표입니다.
 *
 * 그림1.png
 *
 * 대진표의 각 칸에는 번호가 매겨져 있고, 0 번은 항상 결승전입니다. 대진표의 맨 아래 칸들 (그림에서는 6, 7, 8, 9, 10 번입니다) 은 출전 선수들이 제비 뽑기를 통하여 차지할 칸들입니다. 1차전은 세 칸이 있으며 3, 4, 5 번인데, 3번과 5번 칸은 각각 두 사람이 경기를 하기로 되어 있으나 4번 칸은 부전승입니다. 따라서 8번 제비를 뽑는 선수는 1차전을 부전승으로 통과하게 됩니다.
 *
 * 또 다른 부전승 칸의 예는 3번입니다. 6번과 7번 제비를 뽑은 선수들 중 1차전 (3번 칸) 을 승리한 선수는 2차전에서 부전승으로 올라가 바로 결승 (0번 칸) 에 진출하여 2번 칸 대전의 승자와 결승전에서 맞붙게 됩니다. 매월 토너먼트의 참가 신청을 받고 인원을 파악하여 그 때마다 이런 대진표를 새로 그린다고 합니다. 부전승은 아무 곳에나 있을 수 있으나, 결승전이 부전승인 경우는 없다고 합니다.
 *
 * 이번 달에 (위 그림의 대진표가 적용되는 토너먼트에) 윤주가 뽑은 제비는 6번입니다. 그리고, 평소에 윤주가 몰래 좋아하던 같은 탁구장에 나오는 남학생인 철희가 9번 제비를 뽑았다는 사실을 알게 되었습니다. 윤주는 철희와 토너먼트에서 만나 이기려면 몇 번의 경기를 이겨야 하는지가 궁금해졌습니다. 물론, 그 전의 경기에서 철희가 탈락하지 않는다는 가정입니다.
 *
 * 윤주가 철희를 토너먼트에서 만나게 되려면 (위 그림의 대진표를 참고) 결승전까지 진출하여야 하고, 철희를 이기려면 결승전에서도 승리해야 합니다. 그러려면 경기 3, 1, 0 을 통과해야 하는데 이 중 경기 1 이 부전승이므로 모두 두 차례의 경기에서 승리해야 합니다. 반대로, 철희의 입장에서 보면 윤주를 토너먼트에서 만나 이기기 위해서는 경기 5, 2, 0 을 모두 이겨야 합니다. 따라서 승리해야 하는 경기의 수는 3 입니다.
 *
 * 토너먼트의 대진표를 나타내는 배열 matches, 내가 뽑은 칸의 번호 me, 그리고 상대방이 뽑은 칸의 번호 opp가 주어집니다. 이때, 토너먼트에서 (상대방 또한 이전에 탈락하지 않는다고 할 때) 상대방을 만나 경기에서 이기려면 그 때까지 몇 차례의 경기에서 이겨야 하는지를 계산하는 solution 함수를 완성해주세요.
 *
 * 제한사항
 * 결승전은 20 차전을 넘지 않습니다. 이에 따라 참가할 수 있는 선수의 최대 수가 제한됩니다.
 * 배열 matches 의 원소들은 (순서를 0 번부터 시작하여) 각 경기를 승리했을 때 진출하게 되는 다음 경기의 칸 번호를 가지고 있습니다.
 *
 * 첫 원소인 0 번 칸은 결승전을 나타내므로, 이 경기를 이겼을 때 진출하게 되는 다음 경기가 없어서 특별히 -1 의 값이 들어 있습니다.
 * 그 외의 경기들은 대진표의 아래로 갈수록 번호가 커지는 규칙을 따릅니다. 준결승전 두 경기는 1번과 2번 칸에 위치하며, 이 경기들 중 하나를 이기면 결승에 진출하므로 배열 matches의 해당 위치에 들어 있는 값은 모두 0 입니다.
 * 결승전에는 부전승이 없습니다. 따라서 항상 1번과 2번 경기가 준결승전 두 경기입니다.
 * 대진표의 가장 아래 줄에 있는 칸들은 제비 뽑기를 통하여 출전 선수들을 배치할 칸들이므로, 이 번호들은 배열 matches 에는 등장하지 않습니다.
 * 입력 me와 opp는 대진표의 가장 아래 줄에 해당하는 번호로 주어짐이 보장됩니다. 즉, 이 값들은 배열 matches 에는 등장하지 않는 값이지만, 배열 matches의 길이를 k 라고 할 때 k보다는 작은 값입니다.
 *
 * 입출력 예
 * matches	me	opp	answer
 * [-1, 0, 0, 1, 2, 2, 3, 3, 4, 5, 5]	6	9	2
 * [-1, 0, 0, 1, 2, 2, 3, 3, 4, 5, 5]	9	6	3
 * [-1, 0, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 9, 10, 10, 11, 11]	16	13	3
 * 입출력 예 설명
 * 입출력 예 #1
 * 첫번째와 입출력 예는 위 지문에서 예로 든 대진표에서 윤주(6번)가 철희(9번)를 토너먼트에서 만나 이기기 위하여 필요한 승리의 수를 계산한 것입니다. 그 설명은 문제의 지문에 들어 있습니다.
 *
 * 입출력 예 #2
 * 두번째 입출력 예는 위 지문에서 예로 든 대진표에서 철희(9번)가 윤주(6번)를 토너먼트에서 만나 이기기 위하여 필요한 승리의 수를 계산한 것입니다. 그 설명은 문제의 지문에 들어 있습니다.
 *
 * 입출력 예 #3
 * pic1_.png
 * 세번째 입출력 예에서는 16번 제비를 뽑은 선수가 13번 제비를 뽑은 선수를 토너먼트에서 만나 이기기 위하여 필요한 승리의 수를 계산합니다. 이 경우에도 두 선수는 결승전까지 진출해야 비로소 서로 경기를 가지게 되는데, 16번 선수가 13번 선수를 이기기 위해서는 1차전 부전승 (9번) 을 거치고 나서 준준결승전 (4번), 준결승전 (2번), 그리고 마지막으로 결승전 (0번) 에서 승리해야 합니다. 필요한 승리의 수인 3 을 리턴합니다.
 * </pre>
 */
public class Solution {
    public int solution(int[] matches, int me, int opposite) {
        int myPosition = matches[me];
        int oppositePosition = matches[opposite];
        Map<Integer, Integer> positionMap = new HashMap<>();
        for (int match : matches) {
            positionMap.put(match, positionMap.getOrDefault(match, 0) + 1);
        }
        int matchCount = 0;
        positionMap.entrySet().forEach(System.out::println);
        while (myPosition != oppositePosition) {
            if (me > opposite) {
                if (positionMap.get(myPosition) > 1) {
                    matchCount++;
                }
                me = (me % 2 == 0) ? me / 2 : (me + 1) / 2;
                myPosition = matches[me];
                System.out.println("me = " + me);
                System.out.println("myPosition = " + myPosition);
            } else {
                opposite = (opposite % 2 == 0) ? opposite / 2 : (opposite + 1) / 2;
                oppositePosition = matches[opposite];
            }
        }
        return matchCount;
    }

    static class TreeNode {
        public int value;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int value) {
            this.value = value;
        }
    }
}
